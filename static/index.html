<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Êô∫ËÉΩËØ≠Èü≥Âä©Êâã</title>
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAJESURBVFhH7ZbNahRBFIXvqZ7EGQxowI0uXKgbQVwKWYgvcO0T6BOIL+DGvUsFQX0CwUUUJMsIgmQXhKyEBOKMk5np+6tunOrq6p7p9p8sAh4YpqvrnO+eW12VGa1atWrVqtV/pu7s0bvO7OSgM71+sRCWq+nZ0WvnYiC5P0wHhVpz9QrGZEThRPP1dGd4ZxjL2mR0w4qsNAa8IZ0Q7xJvxXvxSUyE3/N4LWzFWFdGRkZHRoOFqZiJmXgrPohP4rP4Jr6LH+KXmIuf4qf4Ln6I7+KLmIqZeC8m4rWYiOfiuTgW+8JrjXtGK+YbzWDlWByJQ7EnDsSu2BE7Yls8FI/FY/FIPBTbYks8EJvioXgg7os1cU+si01xT9wVd8RtcUvcFDfEdXFNXBVXxGVxSVwUF8R5cU6cFWfEaXFKnBQnxHFxTBwVR8QhsSH6hNca94zYzDeCwco+sSd2xY7YElvigXgkHomH4r7YFJvintgQ98SauCvWxR1xW9wUN8R1cU1cFVfEZXFJXBQXxHlxTpwVZ8RpcUqcFCfEcXFMHBVHxGGxIfqE1xr3jFbMN5rByj6xK3bEttgSD8Qj8Ug8FPfFptgU98SGuCfWxF2xLu6I2+KmuCGui2viqrgizolz4qw4I06LU+KkOCGOi2PiqDgiDosN0Se81rhnxGa+EQxW9oktsSUeiPvioXgg7otNcU/cFTfFDXFdXBNXxRVxWVwSF8V5cU6cFWfEaXFKnBQnxPF/4G+oVatWrVq1+qfq9H4D6IXXz+BHxmYAAAAASUVORK5CYII=">
    <script src="https://cdn.jsdelivr.net/npm/vue@3.3.4/dist/vue.global.prod.js"></script>
    <style>
        :root {
            --primary-color: #4a90e2;
            --success-color: #4CAF50;
            --error-color: #f44336;
            --text-color: #333;
            --bg-color: #f5f7fa;
            --card-bg: #ffffff;
            --border-radius: 12px;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
        }

        .container {
            max-width: 900px;
            margin: 2rem auto;
            padding: 0 20px;
        }

        header {
            text-align: center;
            margin-bottom: 2rem;
            padding: 2rem 0;
            background: linear-gradient(135deg, var(--primary-color), #2c5282);
            color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
        }

        header h1 {
            margin: 0;
            font-size: 2.5rem;
            font-weight: 600;
        }

        .section {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            padding: 2rem;
            margin-bottom: 1.5rem;
            box-shadow: var(--shadow);
            transition: transform 0.2s;
        }

        .section:hover {
            transform: translateY(-2px);
        }

        .section h2 {
            margin-top: 0;
            color: var(--primary-color);
            font-size: 1.8rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .section h2 i {
            font-size: 1.5rem;
        }

        .recording-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin: 1.5rem 0;
        }

        .control-btn {
            padding: 0.8rem 1.5rem;
            border: none;
            border-radius: var(--border-radius);
            background-color: var(--primary-color);
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .control-btn i {
            font-size: 1.2rem;
        }

        .control-btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .control-btn:hover:not(:disabled) {
            background-color: #357abd;
            transform: translateY(-1px);
        }

        .transcript-area {
            background: var(--bg-color);
            border-radius: var(--border-radius);
            padding: 1.5rem;
            min-height: 120px;
            margin: 1rem 0;
            border: 2px solid #e1e8f0;
        }

        .transcript {
            white-space: pre-wrap;
            word-break: break-word;
            font-size: 1.1rem;
            color: var(--text-color);
        }

        .transcript.processing {
            opacity: 0.7;
        }

        .speech-controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 1.5rem;
        }

        .status {
            margin-top: 1rem;
            padding: 1rem;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 500;
            animation: fadeIn 0.3s ease;
        }

        .status-ok {
            background-color: #e8f5e9;
            color: var(--success-color);
            border: 1px solid #c8e6c9;
        }

        .status-error {
            background-color: #ffebee;
            color: var(--error-color);
            border: 1px solid #ffcdd2;
        }

        ol {
            padding-left: 1.5rem;
            margin: 1rem 0;
        }

        li {
            margin-bottom: 1rem;
            color: #4a5568;
            font-size: 1.1rem;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .recording .control-btn {
            animation: pulse 2s infinite;
            background-color: var(--error-color);
        }

        .icon {
            display: inline-block;
            width: 24px;
            height: 24px;
            margin-right: 8px;
            vertical-align: middle;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    <!-- Ê∑ªÂä†ÂõæÊ†áÂ∫ì -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@mdi/font@6.5.95/css/materialdesignicons.min.css">
</head>
<body>
    <div id="app">
        <div class="container">
            <header>
                <h1>üéôÔ∏è Êô∫ËÉΩËØ≠Èü≥Âä©Êâã</h1>
            </header>

            <div class="section" :class="{ 'recording': isRecording }">
                <h2><i class="mdi mdi-microphone"></i> ËØ≠Èü≥ËØÜÂà´</h2>
                <div class="recording-controls">
                    <button 
                        :disabled="isRecording" 
                        @click="startRecording"
                        class="control-btn"
                    >
                        <i class="mdi mdi-record"></i>
                        ÂºÄÂßãÂΩïÈü≥
                    </button>
                    <button 
                        :disabled="!isRecording" 
                        @click="stopRecording"
                        class="control-btn"
                    >
                        <i class="mdi mdi-stop"></i>
                        ÂÅúÊ≠¢ÂΩïÈü≥
                    </button>
                </div>

                <div class="transcript-area">
                    <div v-if="isProcessing" class="loading"></div>
                    <div class="transcript" :class="{ 'processing': isProcessing }">
                        {{ transcriptText }}
                    </div>
                    <div v-if="isRecording" class="text-red-500 mt-2">
                        Ââ©‰ΩôÊó∂Èó¥: {{ remainingTime }}Áßí
                    </div>
                </div>
            </div>

            <div class="section">
                <h2><i class="mdi mdi-volume-high"></i> ËØ≠Èü≥ÂêàÊàê</h2>
                <div id="testAudioSection">
                    <button 
                        @click="testAudioDevice" 
                        class="control-btn"
                    >
                        <i class="mdi mdi-test-tube"></i>
                        ÊµãËØïÈü≥È¢ëËÆæÂ§á
                    </button>
                    <div :class="['status', audioStatus.className]">
                        <i :class="['mdi', audioStatus.className === 'status-ok' ? 'mdi-check-circle' : 'mdi-alert']"></i>
                        {{ audioStatus.text }}
                    </div>
                </div>
                
                <div v-show="hasTranscript" class="speech-controls">
                    <button 
                        @click="playText" 
                        :disabled="isPlaying"
                        class="control-btn"
                    >
                        <i class="mdi mdi-play"></i>
                        Êí≠ÊîæÊúóËØª
                    </button>
                    <button 
                        @click="pauseAudio" 
                        :disabled="!isPlaying && !isPaused"
                        class="control-btn"
                    >
                        <i class="mdi" :class="isPaused ? 'mdi-play' : 'mdi-pause'"></i>
                        {{ isPaused ? 'ÁªßÁª≠' : 'ÊöÇÂÅú' }}
                    </button>
                    <button 
                        @click="stopAudio"
                        :disabled="!isPlaying"
                        class="control-btn"
                    >
                        <i class="mdi mdi-stop"></i>
                        ÂÅúÊ≠¢
                    </button>
                </div>
            </div>

            <div class="section">
                <h2><i class="mdi mdi-information"></i> ‰ΩøÁî®ËØ¥Êòé</h2>
                <ol>
                    <li>ÁÇπÂáª"ÊµãËØïÈü≥È¢ëËÆæÂ§á"Á°ÆËÆ§Á≥ªÁªüÈü≥È¢ëÊòØÂê¶Ê≠£Â∏∏</li>
                    <li>ÁÇπÂáª"ÂºÄÂßãÂΩïÈü≥"Âπ∂ÂÖÅËÆ∏ÊµèËßàÂô®‰ΩøÁî®È∫¶ÂÖãÈ£é</li>
                    <li>ËØ¥ËØùÂÆåÊàêÂêéÁÇπÂáª"ÂÅúÊ≠¢ÂΩïÈü≥"</li>
                    <li>ËØÜÂà´ÁªìÊûú‰ºöËá™Âä®ÊúóËØªÔºå‰πüÂèØ‰ª•‰ΩøÁî®Êí≠ÊîæÊéßÂà∂ÊåâÈíÆÊâãÂä®ÊéßÂà∂</li>
                </ol>
            </div>
        </div>
    </div>

    <script>
        const { createApp, ref, computed, onMounted } = Vue

        const app = createApp({
            setup() {
                let countdownTimer = null;
                const transcriptText = ref('Á≠âÂæÖÂΩïÈü≥...')
                const isProcessing = ref(false)
                const isRecording = ref(false)
                const isPlaying = ref(false)
                const isPaused = ref(false)
                const audioStatus = ref({
                    text: 'Á≠âÂæÖÊµãËØïÈü≥È¢ëËÆæÂ§á...',
                    className: 'status-ok'
                })
                const remainingTime = ref(30)

                const hasTranscript = computed(() => {
                    return transcriptText.value && transcriptText.value.trim() !== '' && 
                           transcriptText.value !== 'Ê≠£Âú®ÂΩïÈü≥...' && 
                           transcriptText.value !== 'Ê≠£Âú®Â§ÑÁêÜ...' &&
                           transcriptText.value !== 'ËØÜÂà´Â§±Ë¥•ÔºåËØ∑ÈáçËØï'
                })

                let mediaRecorder = null
                let audioChunks = []

                let voices = []
                let currentUtterance = null
                let synthesisState = 'idle' 

                const SERVER_CONFIG = {
                    protocol: window.location.protocol,
                    host: window.location.hostname || 'localhost',
                    port: '8000',
                    get baseUrl() {
                        return `${this.protocol}//${this.host}:${this.port}`
                    }
                }

                const transcribeAudio = async (formData) => {
                    try {
                        const response = await fetch(`${SERVER_CONFIG.baseUrl}/transcribe`, {
                            method: 'POST',
                            body: formData
                        })
                        
                        if (!response.ok) {
                            const errorData = await response.json()
                            throw new Error(JSON.stringify(errorData))
                        }
                        
                        return await response.json()
                    } catch (error) {
                        console.error('ËØÜÂà´Â§±Ë¥•:', error)
                        throw error
                    }
                }

                const cleanup = async () => {
                    if (stream) {
                        stream.getTracks().forEach(track => track.stop())
                        stream = null
                    }
                    mediaRecorder = null
                    audioChunks = []
                }

                const startRecording = async () => {
                    try {
                        console.log('ËØ∑Ê±ÇÈ∫¶ÂÖãÈ£éÊùÉÈôê...')
                        remainingTime.value = 30
                        const stream = await navigator.mediaDevices.getUserMedia({ 
                            audio: {
                                channelCount: 1,
                                sampleRate: 16000
                            }
                        })

                        // ÂàõÂª∫ AudioContext Áî®‰∫éÈáçÈááÊ†∑
                        const audioContext = new AudioContext({
                            sampleRate: 16000
                        });
                        
                        const source = audioContext.createMediaStreamSource(stream);
                        const destination = audioContext.createMediaStreamDestination();
                        source.connect(destination);

                        // ‰ΩøÁî®Â§ÑÁêÜÂêéÁöÑÊµÅÂàõÂª∫ MediaRecorder
                        const options = {
                            audioBitsPerSecond: 128000,
                            mimeType: 'audio/webm;codecs=opus'
                        };
                        
                        console.log('‰ΩøÁî®Èü≥È¢ëÊ†ºÂºè:', options.mimeType);
                        mediaRecorder = new MediaRecorder(destination.stream, options);
                        
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                audioChunks.push(event.data);
                            }
                        };
                        
                        mediaRecorder.onstop = async () => {
                            if (countdownTimer) {
                                clearInterval(countdownTimer);
                                countdownTimer = null;
                            }
                            remainingTime.value = 30;

                            if (audioChunks.length === 0) {
                                console.error('Ê≤°ÊúâÂΩïÂà∞Èü≥È¢ëÊï∞ÊçÆ');
                                transcriptText.value = 'Ê≤°ÊúâÂΩïÂà∞Èü≥È¢ëÔºåËØ∑ÈáçËØï';
                                return;
                            }

                            console.log('ÂΩïÈü≥Â∑≤ÂÅúÊ≠¢ÔºåÂºÄÂßãÂ§ÑÁêÜÈü≥È¢ëÊï∞ÊçÆ„ÄÇ');
                            console.log('Èü≥È¢ëÊï∞ÊçÆÂùóÊï∞Èáè:', audioChunks.length);
                            
                            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                            console.log('Èü≥È¢ëÊñá‰ª∂Â§ßÂ∞è:', audioBlob.size, 'bytes');
                            
                            if (audioBlob.size < 1000) {
                                console.error('ÂΩïÈü≥Êñá‰ª∂Â§™Â∞è');
                                transcriptText.value = 'ÂΩïÈü≥Êó∂Èó¥Â§™Áü≠ÔºåËØ∑ÈáçËØï';
                                return;
                            }
                            
                            const formData = new FormData();
                            formData.append('audio_file', audioBlob, 'recording.webm');
                            
                            try {
                                transcriptText.value = 'Ê≠£Âú®ËØÜÂà´...';
                                const data = await transcribeAudio(formData);
                                transcriptText.value = data.text;
                                
                                if (data.text) {
                                    playText();
                                }
                            } catch (error) {
                                console.error('ËØÜÂà´Â§±Ë¥•:', error);
                                transcriptText.value = 'ËØÜÂà´Â§±Ë¥•ÔºåËØ∑ÈáçËØï';
                            } finally {
                                audioChunks.length = 0;
                                stream.getTracks().forEach(track => track.stop());
                                audioContext.close();
                            }
                        };
                        
                        console.log('ÂºÄÂßãÂΩïÈü≥...');
                        isRecording.value = true;
                        audioChunks.length = 0;
                        mediaRecorder.start(10);
                        
                        countdownTimer = setInterval(() => {
                            remainingTime.value--;
                            if (remainingTime.value <= 0) {
                                if (mediaRecorder && mediaRecorder.state === 'recording') {
                                    console.log('ÂΩïÈü≥Êó∂Èó¥Âà∞ÔºåËá™Âä®ÂÅúÊ≠¢');
                                    mediaRecorder.stop();
                                    isRecording.value = false;
                                }
                                clearInterval(countdownTimer);
                                countdownTimer = null;
                            }
                        }, 1000);
                        
                        // 30ÁßíÂêéËá™Âä®ÂÅúÊ≠¢ÂΩïÈü≥
                        setTimeout(() => {
                            if (mediaRecorder && mediaRecorder.state === 'recording') {
                                console.log('ÂΩïÈü≥Êó∂Èó¥Âà∞ÔºåËá™Âä®ÂÅúÊ≠¢');
                                mediaRecorder.stop();
                                isRecording.value = false;
                            }
                        }, 30000);
                        
                    } catch (error) {
                        console.error('ÂΩïÈü≥Â§±Ë¥•:', error);
                        alert('Êó†Ê≥ïËÆøÈóÆÈ∫¶ÂÖãÈ£éÔºåËØ∑Á°Æ‰øùÂ∑≤Êéà‰∫àÊùÉÈôê');
                    }
                };

                const stopRecording = () => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                        isRecording.value = false;
                        if (countdownTimer) {
                            clearInterval(countdownTimer);
                            countdownTimer = null;
                        }
                        remainingTime.value = 30;
                    }
                };

                const initSpeechSynthesis = async () => {
                    if (!window.speechSynthesis) {
                        console.error('ÊµèËßàÂô®‰∏çÊîØÊåÅËØ≠Èü≥ÂêàÊàê');
                        return;
                    }

                    // Á≠âÂæÖËØ≠Èü≥ÂêàÊàêÂàùÂßãÂåñ
                    await new Promise(resolve => {
                        let voices = window.speechSynthesis.getVoices();
                        if (voices.length > 0) {
                            resolve();
                        } else {
                            window.speechSynthesis.onvoiceschanged = () => {
                                voices = window.speechSynthesis.getVoices();
                                resolve();
                            };
                        }
                    });

                    console.log('ËØ≠Èü≥ÂêàÊàêÂàùÂßãÂåñÂÆåÊàê');
                };

                let currentAudio = null;  

                const testAudioDevice = async () => {
                    try {
                        // ÂàõÂª∫Èü≥È¢ë‰∏ä‰∏ãÊñá
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();

                        // ÈÖçÁΩÆÈü≥È¢ëÂèÇÊï∞
                        oscillator.type = 'sine';
                        oscillator.frequency.setValueAtTime(440, audioContext.currentTime); // 440Hz ÊòØÊ†áÂáÜ A Èü≥
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime); // ËÆæÁΩÆÈü≥Èáè‰∏∫ 0.1

                        // ËøûÊé•ËäÇÁÇπ
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);

                        // Êí≠ÊîæÊµãËØïÈü≥
                        oscillator.start();
                        audioStatus.value = {
                            text: 'Èü≥È¢ëËÆæÂ§áÊ≠£Â∏∏ÔºåÂèØ‰ª•ÂºÄÂßã‰ΩøÁî®',
                            className: 'status-ok'
                        };

                        // 200ms ÂêéÂÅúÊ≠¢
                        setTimeout(() => {
                            oscillator.stop();
                            audioContext.close();
                        }, 200);

                        return true;
                    } catch (error) {
                        console.error('Èü≥È¢ëËÆæÂ§áÊµãËØïÂ§±Ë¥•:', error);
                        audioStatus.value = {
                            text: error.message || 'Èü≥È¢ëËÆæÂ§áÂèØËÉΩÊúâÈóÆÈ¢òÔºåËØ∑Ê£ÄÊü•ÊµèËßàÂô®ËÆæÁΩÆ',
                            className: 'status-error'
                        };
                        return false;
                    }
                };

                const stopAudio = () => {
                    if (currentAudio) {
                        currentAudio.pause();
                        currentAudio.currentTime = 0;
                        isPlaying.value = false;
                        isPaused.value = false;
                        currentAudio = null;
                    }
                };

                const pauseAudio = () => {
                    if (!currentAudio) return;
                    
                    if (isPaused.value) {
                        // Â¶ÇÊûúÂΩìÂâçÊòØÊöÇÂÅúÁä∂ÊÄÅÔºåÂàôÁªßÁª≠Êí≠Êîæ
                        currentAudio.play();
                        isPaused.value = false;
                        isPlaying.value = true;
                    } else {
                        // Â¶ÇÊûúÂΩìÂâçÊòØÊí≠ÊîæÁä∂ÊÄÅÔºåÂàôÊöÇÂÅú
                        currentAudio.pause();
                        isPaused.value = true;
                        isPlaying.value = false;
                    }
                };

                const resumeAudio = () => {
                    if (currentAudio && isPaused.value) {
                        currentAudio.play();
                        isPaused.value = false;
                        isPlaying.value = true;
                    }
                };

                const playText = async () => {
                    try {
                        // Â¶ÇÊûúÊúâÊ≠£Âú®Êí≠ÊîæÁöÑÈü≥È¢ëÔºåÂÖàÂÅúÊ≠¢ÂÆÉ
                        stopAudio();

                        const response = await fetch(`${SERVER_CONFIG.baseUrl}/synthesize`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                text: transcriptText.value
                            })
                        });
                
                        if (!response.ok) {
                            throw new Error('ËØ≠Èü≥ÂêàÊàêÂ§±Ë¥•');
                        }
                
                        const audioBlob = await response.blob();
                        const audioUrl = URL.createObjectURL(audioBlob);
                        const audio = new Audio(audioUrl);
                        
                        audio.onended = () => {
                            URL.revokeObjectURL(audioUrl);
                            isPlaying.value = false;
                            isPaused.value = false;
                            currentAudio = null;
                        };
                        
                        audio.onerror = (error) => {
                            console.error('Èü≥È¢ëÊí≠ÊîæÂ§±Ë¥•:', error);
                            URL.revokeObjectURL(audioUrl);
                            isPlaying.value = false;
                            isPaused.value = false;
                            currentAudio = null;
                        };
                        
                        currentAudio = audio;
                        isPlaying.value = true;
                        isPaused.value = false;
                        await audio.play();
                        
                    } catch (error) {
                        console.error('ËØ≠Èü≥ÂêàÊàêÊàñÊí≠ÊîæÂ§±Ë¥•:', error);
                        isPlaying.value = false;
                        isPaused.value = false;
                        currentAudio = null;
                    }
                };

                const cancelText = async () => {
                    window.speechSynthesis.cancel()
                    currentUtterance = null
                    synthesisState = 'idle'
                    isPlaying.value = false
                    isPaused.value = false
                    await new Promise(resolve => setTimeout(resolve, 100))
                };

                onMounted(async () => {
                    await initSpeechSynthesis()
                })

                return {
                    transcriptText,
                    isProcessing,
                    isRecording,
                    isPlaying,
                    isPaused,
                    audioStatus,
                    remainingTime,
                    hasTranscript,
                    startRecording,
                    stopRecording,
                    testAudioDevice,
                    playText,
                    stopAudio,
                    pauseAudio,
                    resumeAudio
                }
            }
        })

        app.mount('#app')
    </script>
</body>
</html>
